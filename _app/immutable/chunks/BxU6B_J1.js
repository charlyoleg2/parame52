import{p as o,i as v,f as p,a as R,c as _,b as s,d as y,g as I,E as b,h as C}from"./B8Npla_b.js";var q={partName:"myPartL",params:[o("D1","mm",10,1,200,1),o("D2","mm",30,10,200,1),o("D3","mm",60,10,200,1),o("L1","mm",40,10,200,1)],paramSvg:{D1:"myPartL_face.svg",D2:"myPartL_face.svg",D3:"myPartL_face.svg",L1:"myPartL_face.svg"},sim:{tMax:100,tStep:.5,tUpdate:500}};function J(l,t,g=""){const e=v(q.partName+g),c=I();e.logstr+=`${e.partName} simTime: ${l}
`;try{const r=t.D1/2,f=t.D2/2,d=t.D3/2,h=t.L1/2,a=Math.asin(h/t.D3);if(t.D1>t.D3)throw`err291: D1 ${t.D1} is too large compare to D3 ${t.D3}`;if(t.D2>t.D3)throw`err292: D2 ${t.D2} is too large compare to D3 ${t.D3}`;if(a>Math.PI/4)throw`err295: L1 ${t.L1} is too large compare to D3 ${t.D3}`;e.logstr+=`myPartL: aL12 ${p(R(a))} degree
`;const m=_(f,0);for(let n=0;n<4;n++){const i=n*Math.PI/2;m.addSegStrokeAP(i+a,d).addSegStrokeAP(i+Math.PI/4,r).addSegStrokeAP(i+Math.PI/2-a,d).addSegStrokeAP(i+Math.PI/2,f)}c.addMainO(m),e.fig={face1:c};const P=e.partName;e.vol={extrudes:[{outName:`subpax_${P}`,face:`${P}_face1`,extrudeMethod:C.eLinearOrtho,length:1,rotate:[0,0,0],translate:[0,0,0]}],volumes:[{outName:`pax_${P}`,boolMethod:b.eIdentity,inList:[`subpax_${P}`]}]},e.sub={},e.logstr+=`myPartL drawn successfully!
`,e.calcErr=!1}catch(r){e.logstr+=r,console.log(r)}return e}var K={pTitle:"My Part-L",pDescription:"A Maltese cross",pDef:q,pGeom:J},z={partName:"myPartM",params:[o("D1","mm",10,1,200,1),o("D2","mm",30,10,200,1),o("D3","mm",60,10,200,1),o("L1","mm",60,10,200,1),o("ES","mm",3,0,40,1),o("EL","mm",3,0,40,1),o("RS","mm",100,5,500,1),o("RL","mm",100,5,500,1),o("AS","degree",3,0,45,1),o("AL","degree",42,0,45,1)],paramSvg:{D1:"myPartM_face.svg",D2:"myPartM_face.svg",D3:"myPartM_face.svg",L1:"myPartM_face.svg",ES:"myPartM_face.svg",EL:"myPartM_face.svg",RS:"myPartM_face.svg",RL:"myPartM_face.svg",AS:"myPartM_face.svg",AL:"myPartM_face.svg"},sim:{tMax:100,tStep:.5,tUpdate:500}};function Q(l,t,g=""){const e=v(z.partName+g),c=I();e.logstr+=`${e.partName} simTime: ${l}
`;try{const r=t.D1/2,f=t.D2/2,d=t.D3/2,h=t.L1/2,a=Math.asin(h/t.D3);if(t.D1>t.D3)throw`err291: D1 ${t.D1} is too large compare to D3 ${t.D3}`;if(t.D2>t.D3)throw`err292: D2 ${t.D2} is too large compare to D3 ${t.D3}`;if(a>Math.PI/4)throw`err295: L1 ${t.L1} is too large compare to D3 ${t.D3}`;e.logstr+=`myPartM: aL12 ${p(R(a))} degree
`;const m=_(f,0),P=s(f,0),n=s(0,0).translatePolar(a,d),L=P.middlePoint(n).translatePolar(P.angleToPoint(n)-Math.PI/2,t.ES),D=s(0,0).translatePolar(Math.PI/4,r),M=n.middlePoint(D).translatePolar(n.angleToPoint(D)+Math.PI/2,t.EL),A=s(0,0).translatePolar(Math.PI/2-a,d),u=s(0,f),N=D.middlePoint(A).translatePolar(D.angleToPoint(A)+Math.PI/2,t.EL),$=A.middlePoint(u).translatePolar(A.angleToPoint(u)-Math.PI/2,t.ES);c.addPoint(P),c.addPoint(n),c.addPoint(D),c.addPoint(A),c.addPoint(u),c.addPoint(L),c.addPoint(M),c.addPoint(N),c.addPoint($),m.addPointA(L.cx,L.cy).addPointA(n.cx,n.cy).addSegArc2().addPointA(M.cx,M.cy).addPointA(D.cx,D.cy).addSegArc2().addPointA(N.cx,N.cy).addPointA(A.cx,A.cy).addSegArc2().addPointA($.cx,$.cy).addPointA(u.cx,u.cy).addSegArc2();const E=s(0,0).translatePolar(Math.PI/2+a,d),w=s(0,0).translatePolar(3*Math.PI/4,r),T=s(0,0).translatePolar(Math.PI-a,d),k=s(-f,0);m.addPointA(E.cx,E.cy).addSegArc(t.RS,!1,!0).addPointA(w.cx,w.cy).addSegArc(t.RL,!1,!1).addPointA(T.cx,T.cy).addSegArc(t.RL,!1,!1).addPointA(k.cx,k.cy).addSegArc(t.RS,!1,!0);const O=s(0,0).translatePolar(Math.PI+a,d),G=s(0,0).translatePolar(5*Math.PI/4,r),U=s(0,0).translatePolar(3*Math.PI/2-a,d),j=s(0,-f);m.addPointA(O.cx,O.cy).addSegArc3(Math.PI+y(t.AS),!0).addPointA(G.cx,G.cy).addSegArc3(5*Math.PI/4-y(t.AL),!1).addPointA(U.cx,U.cy).addSegArc3(5*Math.PI/4+y(t.AL),!0).addPointA(j.cx,j.cy).addSegArc3(3*Math.PI/2-y(t.AS),!1);const W=s(0,0).translatePolar(3*Math.PI/2+a,d),B=s(0,0).translatePolar(-Math.PI/4,r),V=s(0,0).translatePolar(-a,d);m.addPointA(W.cx,W.cy).addSegArc(t.RS,!1,!0).addPointA(B.cx,B.cy).addSegArc(t.RL,!1,!1).addPointA(V.cx,V.cy).addSegArc(t.RL,!1,!1).closeSegArc(t.RS,!1,!0),c.addMainO(m),e.fig={face1:c};const S=e.partName;e.vol={extrudes:[{outName:`subpax_${S}`,face:`${S}_face1`,extrudeMethod:C.eLinearOrtho,length:1,rotate:[0,0,0],translate:[0,0,0]}],volumes:[{outName:`pax_${S}`,boolMethod:b.eIdentity,inList:[`subpax_${S}`]}]},e.sub={},e.logstr+=`myPartM drawn successfully!
`,e.calcErr=!1}catch(r){e.logstr+=r,console.log(r)}return e}var X={pTitle:"My Part-M",pDescription:"A Scout-cross for illustration the three ways for defining arcs",pDef:z,pGeom:Q},F={partName:"myPartN",params:[o("D1","mm",10,1,200,1),o("D2","mm",30,10,200,1),o("D3","mm",60,10,200,1),o("L1","mm",60,10,200,1),o("AS","degree",3,0,45,1),o("AL","degree",42,0,45,1),o("RC1","mm",2,0,30,1),o("RC2","mm",2,0,30,1),o("RC3","mm",2,0,30,1),o("RC4","mm",2,0,30,1)],paramSvg:{D1:"myPartN_face.svg",D2:"myPartN_face.svg",D3:"myPartN_face.svg",L1:"myPartN_face.svg",AS:"myPartN_face.svg",AL:"myPartN_face.svg",RC1:"myPartN_face.svg",RC2:"myPartN_face.svg",RC3:"myPartN_face.svg",RC4:"myPartN_face.svg"},sim:{tMax:100,tStep:.5,tUpdate:500}};function Y(l,t,g=""){const e=v(F.partName+g),c=I();e.logstr+=`${e.partName} simTime: ${l}
`;try{const r=t.D1/2,f=t.D2/2,d=t.D3/2,h=t.L1/2,a=Math.asin(h/t.D3);if(t.D1>t.D3)throw`err291: D1 ${t.D1} is too large compare to D3 ${t.D3}`;if(t.D2>t.D3)throw`err292: D2 ${t.D2} is too large compare to D3 ${t.D3}`;if(a>Math.PI/4)throw`err295: L1 ${t.L1} is too large compare to D3 ${t.D3}`;e.logstr+=`myPartN: aL12 ${p(R(a))} degree
`;const m=_(f,0);for(let n=0;n<4;n++){const i=n*Math.PI/2,L=s(0,0).translatePolar(i+a,d),D=s(0,0).translatePolar(i+Math.PI/4,r),x=s(0,0).translatePolar(i+Math.PI/2-a,d),M=s(0,0).translatePolar(i+Math.PI/2,f);m.addPointA(L.cx,L.cy).addSegArc3(i+y(t.AS),!0).addCornerRounded(t.RC1).addPointA(D.cx,D.cy).addSegArc3(i+Math.PI/4-y(t.AL),!1).addCornerWidened(t.RC2).addPointA(x.cx,x.cy).addSegArc3(i+Math.PI/4+y(t.AL),!0).addCornerWideAcc(t.RC3).addPointA(M.cx,M.cy).addSegArc3(i+Math.PI/2-y(t.AS),!1).addCornerRounded(t.RC4)}c.addMainO(m),e.fig={face1:c};const P=e.partName;e.vol={extrudes:[{outName:`subpax_${P}`,face:`${P}_face1`,extrudeMethod:C.eLinearOrtho,length:1,rotate:[0,0,0],translate:[0,0,0]}],volumes:[{outName:`pax_${P}`,boolMethod:b.eIdentity,inList:[`subpax_${P}`]}]},e.sub={},e.logstr+=`myPartN drawn successfully!
`,e.calcErr=!1}catch(r){e.logstr+=r,console.log(r)}return e}var Z={pTitle:"My Part-N",pDescription:"A Scout-cross for illustration a combination of arcs and modified corners",pDef:F,pGeom:Y};const H={"desi52/myPartL":K,"desi52/myPartM":X,"desi52/myPartN":Z};function tt(l){const t=/^.*\//g;return l.replace(t,"")}function et(l){const t={};for(const g of Object.keys(l)){const e=tt(g);t[e]=`/${g}`}return t}function ot(l){const t=[];for(const g of Object.keys(l))t.push(g);return t}const rt=et(H),nt=ot(H);export{H as a,rt as b,nt as d};
